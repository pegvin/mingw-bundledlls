#!/usr/bin/env python3

import subprocess
import os.path
import argparse
import shutil

# This blacklist may need extending
blacklist = [
	"advapi32.dll", "kernel32.dll", "msvcrt.dll", "ole32.dll", "user32.dll",
	"ws2_32.dll", "comdlg32.dll", "gdi32.dll", "imm32.dll", "oleaut32.dll",
	"shell32.dll", "winmm.dll", "winspool.drv", "wldap32.dll",
	"ntdll.dll", "d3d9.dll", "mpr.dll", "crypt32.dll", "dnsapi.dll",
	"shlwapi.dll", "version.dll", "iphlpapi.dll", "msimg32.dll", "setupapi.dll",
	"opengl32.dll", "dwmapi.dll", "uxtheme.dll", "secur32.dll", "gdiplus.dll",
	"usp10.dll", "comctl32.dll", "wsock32.dll", "netapi32.dll", "userenv.dll",
	"avicap32.dll", "avrt.dll", "psapi.dll", "mswsock.dll", "glu32.dll",
	"bcrypt.dll", "rpcrt4.dll", "hid.dll", "dbghelp.dll",
	# directx 3d 11 
	"d3d11.dll", "dxgi.dll", "dwrite.dll"
]


def FindDLLPath(filename, path_prefixes):
	for path_prefix in path_prefixes:
		path = os.path.join(path_prefix, filename)
		path_low = os.path.join(path_prefix, filename.lower())
		if os.path.exists(path):
			return path
		if os.path.exists(path_low):
			return path_low

	else:
		raise RuntimeError(
			"Can't find " + filename + ". If it is an inbuilt Windows DLL, "
			"please add it to the blacklist variable in the script and send "
			"a pull request!"
		)


def GetExecutableDLLs(path, path_prefixes, seen):
	ret = [path]
	output = subprocess.check_output(["objdump", "-p", path]).decode("utf-8", "replace").split("\n")
	for line in output:
		if not line.startswith("\tDLL Name: "):
			continue

		dep = line.split("DLL Name: ")[1].strip()
		ldep = dep.lower()

		if ldep in blacklist:
			continue

		if ldep in seen:
			continue

		dep_path = FindDLLPath(dep, path_prefixes)
		seen.add(ldep)
		subdeps = GetExecutableDLLs(dep_path, path_prefixes, seen)
		ret.extend(subdeps)

	return ret

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument(
		"executable",
		help="EXE or DLL file that you need to bundle dependencies for"
	)
	parser.add_argument(
		"--copy",
		action="store_true",
		help="In addition to printing out the dependencies, also copy them next to the executable"
	)
	parser.add_argument(
		"--search-dir",
		default=f'/{os.environ.get("MSYSTEM", "mingw64").lower()}/bin/',
		help="Set the directories to search in, splitted by a colon"
	)
	parser.add_argument(
		"--upx",
		action="store_true",
		help="Only valid if --copy is provided. Run UPX on all the DLLs and EXE."
	)

	args = parser.parse_args()
	if args.upx and not args.copy:
		raise RuntimeError("Can't run UPX if --copy hasn't been provided.")

	searchDir = [path for path in args.search_dir.split(":") if path]
	print("Search directories: %s" % args.search_dir)
	allDLLs = set(GetExecutableDLLs(args.executable, searchDir, set()))
	allDLLs.remove(args.executable)

	print("\n".join(allDLLs))

	if args.copy:
		print("Copying enabled, will now copy all dependencies next to the executable.\n")
		parent_dir = os.path.dirname(os.path.abspath(args.executable))
		for dll in allDLLs:
			target = os.path.join(parent_dir, os.path.basename(dll))
			try:
				print("Copying '%s' to '%s'" % (dll, target))
				shutil.copy(dll, parent_dir)
			except shutil.SameFileError:
				print("Dependency '%s' was already in target directory, skipping..." % (dll))

			if args.upx:
				subprocess.call(["upx", target])


if __name__ == "__main__":
	main()


